<html>

<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
</head>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body,
    html {
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .container {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
    }

    .top-box {
        flex: 1;
        background-color: #E6ECF5;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        /* width: 100%; */
    }

    .bottom-container {
        border-top: 2px solid black;
        display: flex;
        flex: 1;
    }

    .bottom-left,
    .bottom-right {
        display: flex;
        justify-content: center;
        align-items: flex-start;
    }

    .bottom-left {
        flex: 1;
        background-color: #E6ECF5;
        display: flex;
        justify-content: flex-start;
        /* align-items: center; */
        /* height: 100%; */
        border-right: 2px solid black;

        height: 900px;
        position: relative;

    }

    #countyColorLegend {
        position: absolute;
        top: 50%;
        left: 27%;
        /* top: 100px; */
        /* transform: translate(250px, 980px); */
    }

    .bottom-right {
        flex: 1;
        background-color: #E6ECF5;

        /* position: relative; */
        /* display: flex; */
        justify-content: flex-start;
        /* align-items: center; */
        height: 100%;
    }

    .main-title {
        padding: 10px 20px;
        margin: 0 4px;
        border: none;
        border-radius: 4px;
        font-family: serif;
        position: absolute;
        top: 5%;
        left: 27%;
        font-size: 40px;
    }

    .county {
        fill: gray;
        stroke: black;
        stroke-width: 1px;
    }

    .state {
        stroke: black;
        stroke-width: 1px;
        fill: gray;
    }

    .outline {
        fill: none;
        stroke: black;
        stroke-width: 2px;
    }

    .statemap {
        fill: white;
        position: absolute;
        gap: 8px;
        padding: 10px;
        border: none;
        border-radius: 4px;
        top: 90%;
    }

    .county-outline {
        fill: none;
        stroke: black;
        stroke-width: 1px
    }

    #button-bar button,
    #button-bar-state button,
    #line-button button,
    #line-button2 button {
        width: 175px;
        height: 50px;
    }

    #button-bar {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
        padding: 20px;
        left: 10%;
        position: absolute;
    }

    #line-button {
        position: relative;
        top: 47%;
        left: 11%;
        transform: translateX(-50%);
        /* margin-top: 80%; */
        /* position: relative; */
    }

    #line-button2 {
        position: relative;
        top: 17%;
        left: -8%;
        transform: translateX(-50%);
        /* margin-top: 80%; */
        /* position: relative; */

    }

    #button-bar button.health-spending,
    #line-button button.health-spending,
    #line-button2 button.health-spending {
        padding: 10px 20px;
        margin: 0 4px;
        border: 2px solid #11bc4a;
        border-radius: 4px;
        background-color: white;
        color: #11bc4a;
        cursor: pointer;
        font-family: serif;
        margin-bottom: 7%;
        transition: 0.5s;
        /* transition-duration: 0.4s; */
        /* position: absolute; */
        /* top: 99%; */
        /* left: 99%; */
        display: block
    }

    #button-bar button.health-spending:hover,
    #button-bar button.health-spending.active,
    #line-button button.health-spending:hover,
    #line-button button.health-spending.active,
    #line-button2 button.health-spending:hover,
    #line-button2 button.health-spending.active {
        background-color: #11bc4a;
        color: white;
    }

    #button-bar button.covid-deaths,
    #line-button button.covid-deaths,
    #line-button2 button.covid-deaths {
        padding: 10px 20px;
        margin: 0 4px;
        border: 2px solid #ba1a5a;
        border-radius: 4px;
        background-color: white;
        color: #ba1a5a;
        cursor: pointer;
        margin-bottom: 7%;

        font-family: serif;
        transition: 0.5s;
        /* transition-duration: 0.4s; */
        /* position: absolute; */
        /* top: 99%; */
        /* left: 99%; */
        display: block
    }

    #button-bar button.covid-deaths:hover,
    #button-bar button.covid-deaths.active,
    #line-button button.covid-deaths:hover,
    #line-button button.covid-deaths.active,
    #line-button2 button.covid-deaths:hover,
    #line-button2 button.covid-deaths.active {
        background-color: #ba1a5a;
        color: white;
    }

    #button-bar button.covid-cases,
    #line-button button.covid-cases,
    #line-button2 button.covid-cases {
        padding: 10px 20px;
        margin: 0 4px;
        border: 2px solid #4B7EF5;
        border-radius: 4px;
        background-color: white;
        color: #4B7EF5;
        cursor: pointer;
        font-family: serif;
        transition: 0.5s;
        /* transition-duration: 0.4s; */
        /* position: absolute; */
        /* top: 99%; */
        /* left: 99%; */
        display: block
    }

    #button-bar button.covid-cases:hover,
    #button-bar button.covid-cases.active,
    #line-button button.covid-cases:hover,
    #line-button button.covid-cases.active,
    #line-button2 button.covid-cases:hover,
    #line-button2 button.covid-cases.active {
        background-color: #4B7EF5;
        color: white;
    }

    #button-bar-state button.county-cases {
        padding: 10px 20px;
        margin: 0 4px;
        border: 2px solid #4B7EF5;
        border-radius: 4px;
        background-color: white;
        color: #4B7EF5;
        cursor: pointer;
        font-family: serif;
        transition: 0.5s;
        display: block;
    }

    #button-bar-state button.county-cases:hover,
    #button-bar-state button.county-cases.active {
        background-color: #4B7EF5;
        color: white;
    }

    #button-bar-state button.county-deaths {
        padding: 10px 20px;
        margin: 0 4px;
        border: 2px solid #ba1a5a;
        border-radius: 4px;
        background-color: white;
        color: #ba1a5a;
        cursor: pointer;
        font-family: serif;
        transition: 0.5s;
        display: block;
    }

    #button-bar-state button.county-deaths:hover,
    #button-bar-state button.county-deaths.active {
        background-color: #ba1a5a;
        color: white;
    }


    #button-bar button:hover {
        opacity: 0.9;
        color: rgb(162, 234, 236)
    }

    #line-button button:hover {
        opacity: 0.9;
        color: rgb(162, 234, 236)
    }

    #line-button2 button:hover {
        opacity: 0.9;
        color: rgb(162, 234, 236)
    }

    #button-bar-state {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
        padding: 20px;
        left: 30%;
        position: relative;
    }

    .ustooltip,
    .statetooltip,
    .charttooltip {
        pointer-events: none;
    }

    .gridlines line {
        stroke: grey;
        stroke-width: 0.5px;
    }

    .gridlines .domain {
        stroke: none;
    }


    .background {
        z-index: 1;
        position: absolute;
    }

    .gridlines line {
        stroke: #d0cccc;
        z-index: 10;
        position: absolute;
    }

    .lineChart {
        position: relative;
        top: 70px;
        right: 15%;
    }

    #colorLegend {
        position: relative;
        /* top: 30px; */
        left: 18%;
    }

    #textbox {
        /* 
        position: absolute;
        left: 69%; */
        position: relative;
        /* top: 30px; */
        left: 45%;
        border: 2px solid black;
        background-color: white;
        height: 290px;
        font-size: 19px;
        width: 19%;
        padding: 10px;

    }

    #usmap {
        top: 15%;
        left: 20%;
        position: absolute;
    }

    .title3 {
        padding: 10px 20px;
        margin: 0 4px;
        border: none;
        border-radius: 4px;
        font-family: serif;
        position: absolute;
        top: 615px;
        left: 35%;
        font-size: 30px;
    }

    #textbox3 {
        padding: 10px 20px;
        margin: 0 4px;
        border-radius: 4px;
        font-family: serif;
        position: relative;
        top: 615px;
        left: 35%;
        font-size: 15px;
        border: 2px solid black;
        background-color: white;
        width: 10%;
        height: 290px;

    }




    /* Adjust the bottom-left container to be tall enough */


    /* Adjust the button to fit within the container */
</style>

<body>
    <div class="container">
        <div class="top-box">
            <div class="main-title">COVID-19 Trends Across the U.S. in 2020</div>
            <div id="button-bar"></div>
            <div id="textbox"> This interactive visualization is meant to illustrate the relationship between health
                spending and covid-19 deaths across the United States from 2020. Hover over each state to see the exact
                health spending per capita or COVID-19 deaths/ cases in 2020 as a percentage of that state's population.
                Clicking on a state will
                reveal county level data, displaying mask usage and county level deaths in the state map below.
            </div>
            <!-- <div id="button-bar-state" style="display: none;"></div> -->
            <svg id="usmap" height="500" width="900" style="margin: auto 5px;
           float: left; "></svg>
            <!-- <div class="usmap-description">Box holder</div> -->
            <svg class="colorLegend" id="colorLegend" height="100" width="440"
                style="margin-top: 30%; margin-left: 1%;"></svg>
        </div>

        <div class="bottom-container">
            <div class="bottom-left">
                <div id="button-bar-state"></div>
                <svg id="statemap" height="450" width="500"></svg>
                <svg class="countyColorLegend" id="countyColorLegend" height="100" width="400"></svg>
            </div>
            <div class="bottom-right">
                <div id="line-button"></div>
                <div id="line-button2"></div>
                <!-- <div id="line-button"></div> -->
                <div class="title3">Comparison Across States</div>
                <div id="textbox3">This graph compares health spending, COVID-19 cases, and COVID-19 deaths across all
                    50 states. Click the buttons to set which variable is on which axis and hover over each data point
                    to see which state is being represented. </div>


                <svg class="lineChart" id="chart" height="520" width="600"></svg>
                <!-- <svg id="statemap" height="500" width="500" style="margin:20px"></svg> -->
                <!-- <svg id="colorLegend" height="80" width="600" style="background: #fff; margin-top:30px"></svg> -->
            </div>
        </div>
    </div>


    <script>
        const buttonLabels = {
            0: "Health Spending \u{1F4B0}",
            1: "COVID-19 Deaths \u{2620} ",
            2: "COVID-19 Cases  \u{26A0} "
        }
        const buttonClasses = {
            0: "health-spending",
            1: "covid-deaths",
            2: "covid-cases"
        }

        const stateButtonLabels = {
            0: "Total Cases \u{26A0}",
            1: "Total Deaths  \u{2620}",
        };
        const stateButtonClasses = {
            0: "county-cases",
            1: "county-deaths"
        };

        const lineButtonLabels = {
            0: "Health Spending \u{1F4B0}",
            1: "COVID-19 Deaths \u{2620} ",
            2: "COVID-19 Cases  \u{26A0} "
        };

        const lineButtonClasses = {
            0: "health-spending",
            1: "covid-deaths",
            2: "covid-cases"
        };


        // VISUALIZATION 1 - map of US with health care spending for each state
        const svg1 = d3.select('svg#usmap');
        const width1 = svg1.attr('width');
        const height1 = svg1.attr('height');
        const margins1 = { top: 20, right: 20, bottom: 42, left: 20 };
        const mapWidth1 = width1 - margins1.left - margins1.right;
        const mapHeight1 = height1 - margins1.top - margins1.bottom;
        const usmap = svg1.append("g")
            .attr("transform", "translate(" + margins1.left + "," + margins1.top + ")");


        // VISUALIZATION 2 - covid cases by county
        const svg2 = d3.select('svg#statemap');
        const width2 = svg2.attr('width');
        const height2 = svg2.attr('height');
        const margins2 = { top: 20, right: 75, bottom: 42, left: 65 };
        const mapWidth2 = width2 - margins2.left - margins2.right;
        const mapHeight2 = height2 - margins2.top - margins2.bottom;
        const statemap = svg2.append("g")
            .attr("transform", "translate(" + margins2.left + "," + margins2.top + ")");
        let currentStateToggle = 0; // show mask usage data initially


        // VISUALIZATION 3 - line graph
        const svg3 = d3.select('svg#chart');
        const width3 = svg3.attr('width');
        const height3 = svg3.attr('height');
        const margins3 = { top: 35, right: 90, bottom: 50, left: 80 };
        const chartWidth = width3 - margins3.left - margins3.right;
        const chartHeight = height3 - margins3.top - margins3.bottom;
        // chart background color
        svg3.append('rect')
            .attr("x", margins3.left - 10)
            .attr("y", margins3.top - 10)
            .attr("width", chartWidth + 20)
            .attr("height", chartHeight + 20)
            .style("fill", "#FEE5D9")
            .style("stroke", "black");

        // gridlines & chart itself
        let annotations = svg3.append("g").attr("id", "annotations");
        let chartArea = svg3.append('g')
            .attr('transform', `translate(${margins3.left},${margins3.top})`);


        const requestData = async function () {
            // import topoJSON for US map
            const us = await d3.json("us-counties.json");
            console.log(us);

            // VISUALIZATION 1
            // draw US map
            var states = topojson.feature(us, us.objects.states);
            var statesMesh = topojson.mesh(us, us.objects.states);
            var projection1 = d3.geoAlbersUsa().fitSize([mapWidth1, mapHeight1], states);
            var path1 = d3.geoPath().projection(projection1);

            // state paths
            let statePaths = usmap.selectAll("path.state").data(states.features)
                .join("path")
                .attr("class", "state")
                .attr("d", path1)
                .on('mouseover', mouseoverState)
                .on('mouseout', mouseoutState)
                .on('click', (event, d) => {
                    console.log(d);
                    updateStateMap(d);
                });

            usmap.append("path").datum(statesMesh)
                .attr("class", "outline")
                .attr("d", path1);

            // import health spending data
            const healthSpendingData = await d3.csv("health_spending_data.csv");
            const hsc = 'Health Spending per Capita'
            healthSpendingData.forEach((d, i) => {
                d[hsc] = d[hsc].replace(/[$, ]/g, "").trim();
                d[hsc] = Number(d[hsc]);
            })

            // health data
            var healthSpendingDict = {};
            healthSpendingData.forEach(d => {
                const spending = parseFloat(d["Health Spending per Capita"]);
                healthSpendingDict[d.Location] = { total: spending };
            });

            // import population data
            const popData = await d3.csv("us_pop_by_state.csv", d3.autoType);

            // import COVID data
            const covidData = await d3.csv("us-counties-2020.csv", d3.autoType);

            // extract cumulative data from last day of 2020
            const latestCovidData = covidData.filter(d => {
                return d.date.toString().includes("Dec") && d.date.toString().includes("30") && d.date.toString().includes("2020"); //fix this later to include DEC 31 if possible ~Abdul
            });

            // covid deaths data dictionary, by county
            var fipsDeathsDict = {};
            latestCovidData.forEach(d => {
                // Ensure the FIPS code is always 5 digits long by padding with leading zeros
                if (d.fips == null) return;
                const fips = d.fips.toString().padStart(5, '0');

                if (fips in fipsDeathsDict) {
                    fipsDeathsDict[fips] += d.deaths;
                } else {
                    fipsDeathsDict[fips] = d.deaths;
                }
            });

            // covid cases data dictionary, by county
            var fipsCasesDict = {};
            latestCovidData.forEach(d => {
                if (d.fips == null) return;
                const fips = d.fips.toString().padStart(5, '0');
                if (fips in fipsCasesDict) {
                    fipsCasesDict[fips] += d.cases;
                } else {
                    fipsCasesDict[fips] = d.cases;
                }
            });

            // covid deaths data - latestCovidData summed up for counties in each state
            var covidDeathsDict = {};
            latestCovidData.forEach(d => {
                if (d.state in covidDeathsDict) {
                    covidDeathsDict[d.state] = { total: (covidDeathsDict[d.state].total + d.deaths) }
                } else {
                    covidDeathsDict[d.state] = { total: d.deaths }
                }
            });

            // covid deaths normalized to population size (in %)
            var percentDeathsDict = {};
            popData.forEach(d => {
                if (d.state in covidDeathsDict) {
                    percentDeathsDict[d.state] = { total: 100 * (covidDeathsDict[d.state].total / d['2020_census']) }
                } else { }
            })

            // covid cases data - latestCovidData summed up for counties in each state
            var covidCasesDict = {};
            latestCovidData.forEach(d => {
                if (d.state in covidCasesDict) {
                    covidCasesDict[d.state] = { total: (covidCasesDict[d.state].total + d.cases) }
                } else {
                    covidCasesDict[d.state] = { total: d.cases }
                }
            });

            // covid cases normalized to population size (in %)
            var percentCasesDict = {};
            popData.forEach(d => {
                if (d.state in covidCasesDict) {
                    percentCasesDict[d.state] = { total: 100 * (covidCasesDict[d.state].total / d['2020_census']) }
                } else { }
            })

            // *** dictionary where key is fip and value is state 
            const fipsToStateDict = {};

            latestCovidData.forEach(d => {
                if (d.fips == null || d.state == null) return;
                const fips = d.fips.toString().padStart(5, '0');
                fipsToStateDict[fips] = d.state;
            });

            console.log(percentDeathsDict);
            console.log(percentCasesDict);

            console.log(healthSpendingDict);
            console.log(covidDeathsDict);
            console.log(covidCasesDict);

            // array of possible data sets for the US (state-level data)
            //var usData = [healthSpendingDict, covidDeathsDict, covidCasesDict];
            var usData = [healthSpendingDict, percentDeathsDict, percentCasesDict];

            // Currency format for health spending, decimals for deaths & cases (plus converts to %)
            const formatValue = [d3.format("$,.0f"),
            (d => d3.format(".2f")(d) + "%"),
            (d => d3.format(".1f")(d) + "%")]

            function updateUsScale(usToggle) {
                let stateDict = usData[usToggle];
                console.log(stateDict);

                const colorScale = d3.scaleQuantile()
                    .domain(Object.values(stateDict).map(d => d.total))
                    .range(d3.schemeRdPu[4]);

                usmap.selectAll(".state")
                    .style("fill", d => {
                        const stateName = d.properties.name;
                        if (stateDict[stateName]) {
                            return colorScale(stateDict[stateName].total);
                        } else {
                            return "#ccc";
                        }
                    });
                drawLegend("#colorLegend", colorScale, formatValue[usToggle])
            }

            // initialize us map
            let currentUsToggle = 0; // show health spending data initially
            updateUsScale(currentUsToggle);

            // buttons for map of US toggle
            const usKeys = Object.keys(usData);
            usKeys.forEach(d => {
                d3.select("div#button-bar")
                    .append("button")
                    .attr("class", buttonClasses[d])
                    .text(buttonLabels[d])
                    .on("click", function () {
                        d3.selectAll("#button-bar button").classed("active", false);
                        d3.select(this).classed("active", true)
                        currentUsToggle = Number(d);
                        updateUsScale(d);
                    })
            })

            // init selected buttons
            d3.select("#button-bar button").classed("active", true);

            // US map Mouseover tooltip stuff
            let ustooltipWidth = 110;
            let ustooltipHeight = 40;
            let usMouseoverMesh = usmap.append("path")
                .attr("class", "usmouseover outline")
                .style("stroke", "black")
                .style("stroke-width", 3)
                .attr("d", "");

            let ustooltip = usmap.append("g")
                .attr("class", "ustooltip")
                .attr("visibility", "hidden");

            ustooltip.append("rect")
                .attr("fill", "white")
                .attr("stroke", "black")
                .attr("stroke-width", 1)
                .attr("x", -ustooltipWidth / 2.0)
                .attr("y", 0)
                .attr("width", ustooltipWidth)
                .attr("height", ustooltipHeight)

            let stateLabel = ustooltip.append("text")
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "hanging")
                .attr("x", 0)
                .attr("y", 2);

            let usDataLabel = ustooltip.append("text")
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "hanging")
                .attr("x", 0)
                .attr("y", 22);

            // mouseoverState function to show name of state and amount of money on mouseover
            function mouseoverState(event, d) {
                ustooltip.style("visibility", "visible")
                let state = d3.select(this);
                state.style("stroke-width", "4px");

                // state name & data label
                let location = d3.pointer(event);
                let name = state.datum().properties.name;

                stateDict = usData[currentUsToggle];
                let value = stateDict[name].total;

                // show more sig figs than legend format
                const formatValue = [d3.format("$,.0f"), (d => d3.format(".3f")(d) + "%"), (d => d3.format(".2f")(d) + "%")]

                stateLabel.text(name);
                usDataLabel.text(formatValue[currentUsToggle](value));

                let bounds = path1.bounds(state.datum());
                let x = (bounds[0][0] + bounds[1][0]) / 2.0;
                let y = bounds[1][1];
                ustooltip.attr("transform", `translate(${x},${y})`);
                var mo = topojson.mesh(us, us.objects.states, function (a, b) { return a.id === name || b.id === name; });
                usMouseoverMesh.datum(mo).attr("d", path1)
            }

            // get rid of label and reset state attributes
            function mouseoutState() {
                ustooltip.style("visibility", "hidden");
                let state = d3.select(this);
                state.style("stroke-width", "1px");

                usMouseoverMesh.attr("d", "");
            }

            // VISUALIZATION 2 //

            // array of possible data sets for an individual state (county-level data)
            var countyData = [fipsCasesDict, fipsDeathsDict];

            // Initialize with New York
            const nyState = states.features.find(d => d.properties.name === "New York")
            if (nyState) {
                updateStateMap(nyState);
                updateCountyData(nyState, 0);
            }

            // draw map based on button selection
            function updateCountyData(selectedState, countyToggle) {
                const selectedDict = countyData[countyToggle];

                const stateCountyValues = Object.entries(selectedDict)
                    .filter(([fips, value]) => fipsToStateDict[fips] === selectedState.properties.name)
                    .map(([fips, value]) => value);

                const minMax = d3.extent(stateCountyValues, d => d);

                // choose color scale:

                // ["#fff5f0", "#fcbba1", "#fc9272", "#fb6a4a", "#cb181d"]
                //const colorScale = d3.scaleQuantize().domain(minMax)
                //    .range(["#fff5f0", "#fcbba1", "#fc9272", "#fb6a4a", "#cb181d"]);

                //const colorScale = d3.scaleQuantile().domain(stateCountyValues)
                //                                     .range(["#fff5f0", "#fcbba1", "#fb6a4a", "#cb181d"]);

                const colorScale = d3.scaleLog().domain(minMax).interpolate(d => d3.interpolate("#fff5f0", "#cb181d"))

                // color counties based on data
                statemap.selectAll(".county")
                    .style("fill", d => {
                        const countyFips = d.id.toString();
                        const dataValue = selectedDict[countyFips];
                        if (dataValue === 0) { return colorScale(0); }
                        return dataValue ? colorScale(dataValue) : "#ccc";
                    });

                // formatting to reduce crowded numbers
                let formatValue = d3.format("~s");

                drawLegend("#countyColorLegend", colorScale, formatValue);
            }

            // write updateState function to update map 2 with county-level COVID data for selected state
            function updateStateMap(selectedState) {
                // clear previous state
                statemap.selectAll(".county").remove();
                statemap.selectAll(".county-outline").remove();
                statemap.selectAll(".outline").remove();
                d3.select("#button-bar-state").style("display", "none").selectAll("button").remove();

                // add button to new state
                d3.select("#button-bar-state").style("display", "flex");

                Object.keys(stateButtonLabels).forEach(i => {
                    d3.select("#button-bar-state")
                        .append("button")
                        .attr("class", stateButtonClasses[i])
                        .text(stateButtonLabels[i])
                        .on("click", function () {
                            d3.selectAll("#button-bar-state button").classed("active", false);
                            d3.select(this).classed("active", true)
                            currentStateToggle = parseInt(i);
                            updateCountyData(selectedState, currentStateToggle);
                        });
                });

                d3.select("#button-bar-state button").classed("active", true);


                let selectedCounties = us.objects.counties.geometries.filter(function (d) { return selectedState.id == Math.floor(d.id / 1000) });
                var counties = topojson.feature(us, { type: "GeometryCollection", geometries: selectedCounties });
                var countiesMesh = topojson.mesh(us, { type: "GeometryCollection", geometries: selectedCounties });

                // create projection & path for selected state
                var stateProjection = d3.geoAlbersUsa().fitSize([mapWidth2, mapHeight2], selectedState);
                var statePath = d3.geoPath().projection(stateProjection);

                // Draw individual state outline
                statemap.append("path").datum(selectedState)
                    .attr("class", "outline")
                    .attr("d", statePath);

                // Draw counties within the selected state
                statemap.selectAll("path.county").data(counties.features)
                    .join("path")
                    .attr("class", "county")
                    .attr("d", statePath)
                    .on('mouseover', mouseoverCounty)
                    .on('mouseout', mouseoutCounty);

                statemap.append("path").datum(countiesMesh)
                    .attr("class", "county-outline")
                    .attr("d", statePath);

                // initialize map
                updateCountyData(selectedState, 0);

                // State map Mouseover tooltip stuff
                let statetooltipWidth = 160;
                let statetooltipHeight = 40;
                let stateMouseoverMesh = statemap.append("path")
                    .attr("class", "statemouseover outline")
                    .style("stroke", "black")
                    .style("stroke-width", 3)
                    .attr("d", "");

                let statetooltip = statemap.append("g")
                    .attr("class", "statetooltip")
                    .attr("visibility", "hidden");

                statetooltip.append("rect")
                    .attr("fill", "white")
                    .attr("stroke", "black")
                    .attr("stroke-width", 1)
                    .attr("x", -statetooltipWidth / 2.0)
                    .attr("y", 0)
                    .attr("width", statetooltipWidth)
                    .attr("height", statetooltipHeight)

                let countyLabel = statetooltip.append("text")
                    .attr("text-anchor", "middle")
                    .attr("alignment-baseline", "hanging")
                    .attr("x", 0)
                    .attr("y", 2);

                let stateDataLabel = statetooltip.append("text")
                    .attr("text-anchor", "middle")
                    .attr("alignment-baseline", "hanging")
                    .attr("x", 0)
                    .attr("y", 22);

                console.log(fipsCasesDict);

                // mouseoverCounty function to show name of county and data value
                function mouseoverCounty(event, d) {
                    statetooltip.style("visibility", "visible")

                    let county = d3.select(this);
                    county.style("stroke-width", "2px");

                    // make label appear with name of county & value of data
                    let location = d3.pointer(event);
                    let name = county.datum().properties.name;
                    let fips = county.datum().id;
                    let countyDict = (currentStateToggle === 0) ? fipsCasesDict : fipsDeathsDict;
                    let value = countyDict[fips];
                    let formatValue = d3.format(",d");

                    // assign label texts
                    countyLabel.text(name);
                    stateDataLabel.text(value !== undefined ? formatValue(value) : "(No Data)");

                    let bounds = statePath.bounds(county.datum());
                    let x = (bounds[0][0] + bounds[1][0]) / 2.0;
                    let y = bounds[1][1];
                    statetooltip.attr("transform", `translate(${x},${y})`);
                    var mo = topojson.mesh(us, { type: "GeometryCollection", geometries: selectedCounties }, function (a, b) { return a.id === name || b.id === name; });
                    stateMouseoverMesh.datum(mo).attr("d", statePath)
                }

                // clear mouseovers
                function mouseoutCounty() {
                    statetooltip.style("visibility", "hidden");
                    let county = d3.select(this);
                    county.style("stroke-width", "1px");
                    stateMouseoverMesh.attr("d", "");
                }
            }

            // VISUALIZATION 3
            // for reference: usData = [healthSpendingDict, covidDeathsDict, covidCasesDict];

            // line graph tooltip 
            let charttooltip = chartArea.append("g")
                .attr("class", "charttooltip")
                .attr("visibility", "hidden");

            charttooltip.append("rect")
                .attr("fill", "white")
                .attr("stroke", "black")
                .attr("stroke-width", 1)
                .attr("x", -55)
                .attr("y", 0)
                .attr("width", 110)
                .attr("height", 40)

            let circleLabel = charttooltip.append("text")
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "hanging")
                .attr("x", 0)
                .attr("y", 0);

            // generate line graph based on button selections
            function updateLineGraph(xAxisToggle, yAxisToggle) {
                // clear previous data and annotations
                chartArea.selectAll('circle').remove();
                annotations.selectAll('.x.axis').remove();
                annotations.selectAll('.y.axis').remove();
                annotations.selectAll('.x.gridlines').remove();
                annotations.selectAll('.y.gridlines').remove();
                svg3.selectAll('text').remove();

                // find extents and make scales
                const xExtent = d3.extent(Object.values(usData[xAxisToggle]), d => d.total);
                const xScale = d3.scaleLinear().domain(xExtent)
                    .range([0, chartWidth]);

                const yExtent = d3.extent(Object.values(usData[yAxisToggle]), d => d.total);
                const yScale = d3.scaleLinear().domain(yExtent)
                    .range([chartHeight, 0]);

                // axes
                let labels = ["Health Spending (per Capita)",
                    "COVID-19 Deaths (% of State Population)",
                    "COVID-19 Cases (% of State Population)"];

                // different format functions for each type of data
                const formatValue = [(d => "$" + d3.format("~s")(d)),
                (d => d3.format(".2f")(d) + "%"),
                (d => d3.format(".1f")(d) + "%")]

                // y axis
                let leftAxis = d3.axisLeft(yScale).tickFormat(formatValue[yAxisToggle]);
                let leftGridlines = d3.axisLeft(yScale)
                    .tickSize(-chartWidth - 20)
                    .tickFormat("");
                annotations.append("g")
                    .attr("class", "y axis")
                    .attr("transform", `translate(${margins3.left - 10},${margins3.top})`)
                    .call(leftAxis);
                annotations.append("g")
                    .attr("class", "y gridlines")
                    .attr("transform", `translate(${margins3.left - 10},${margins3.top})`)
                    .call(leftGridlines);

                // y axis label
                svg3.append("text").text(labels[yAxisToggle])
                    .attr("x", -chartHeight + 70)
                    .attr("y", 10)
                    .style("font-size", "15px")
                    .attr("transform", "rotate(-90)");

                // x axis
                let bottomAxis = d3.axisBottom(xScale).tickFormat(formatValue[xAxisToggle]);
                let bottomGridlines = d3.axisBottom(xScale)
                    .tickSize(-chartHeight - 20)
                    .tickFormat("");
                annotations.append("g")
                    .attr("class", "x axis")
                    .attr("transform", `translate(${margins3.left},${chartHeight + margins3.top + 10})`)
                    .call(bottomAxis);
                annotations.append("g")
                    .attr("class", "x gridlines")
                    .attr("transform", `translate(${margins3.left},${chartHeight + margins3.top + 10})`)
                    .call(bottomGridlines);

                // x axis label
                svg3.append("text").text(labels[xAxisToggle])
                    .attr("x", chartWidth / 2 + margins3.left)
                    .attr("y", height3 - 10)
                    .style("font-size", "15px")
                    .attr("dominant-baseline", "middle")
                    .attr("text-anchor", "middle");

                // plotting data
                Object.keys(usData[xAxisToggle]).forEach((d, i) => {
                    let stateName = String(d);

                    // check that state is in both datasets
                    if (usData[xAxisToggle][stateName] && usData[yAxisToggle][stateName]) {
                        x = usData[xAxisToggle][stateName].total;
                        y = usData[yAxisToggle][stateName].total;
                    } else {
                        return;
                    }

                    // mouseover label
                    var label = svg3.append("text")
                        .attr("id", "label")
                        .attr("font-size", 15);

                    // plot data
                    chartArea.append('circle')
                        .attr('cx', xScale(x))
                        .attr('cy', yScale(y))
                        .attr('r', 5)
                        .attr("fill", "red")
                        .attr('opacity', 1)
                        .attr('stroke', "darkred")
                        .attr('stroke-width', 1)
                        // on mouseover change color & size, show name of state
                        .on("mouseover", function () {
                            d3.select(this).attr("fill", "#4d759a")
                                .attr("stroke", "#073763")
                                .attr("r", 8)
                                .raise();

                            let textx = xScale(x) + margins3.left + 5;
                            let texty = yScale(y) + margins3.top + -10;
                            console.log(textx, texty);
                            console.log(stateName);
                            label.attr("x", textx - 10).attr("y", texty).text(stateName);
                        })
                        // get rid of changes made on mouseover
                        .on("mouseout", function () {
                            label.text("")
                            d3.select(this).attr("fill", "red")
                                .attr('stroke', "darkred")
                                .attr("r", 5);
                        });
                });
            }

            // initialize toggles - default to covid deaths vs health spending
            let xAxisToggle = 1;
            let yAxisToggle = 0;
            updateLineGraph(xAxisToggle, yAxisToggle);

            // x-axis toggle
            const lineKeys = Object.keys(usData);
            Object.keys(lineButtonLabels).forEach(d => {
                // lineKeys.forEach(d => {
                d3.select("div#line-button")
                    .append("button")
                    .attr("class", lineButtonClasses[d])
                    .text(lineButtonLabels[d])
                    .classed("active", d == xAxisToggle)
                    .on("click", function () {
                        xAxisToggle = Number(d);
                        updateLineGraph(xAxisToggle, yAxisToggle);

                        d3.selectAll("div#line-button button")
                            .classed("active", false);

                        d3.select(this).classed("active", true);
                    })
            });

            // y-axis toggle
            Object.keys(lineButtonLabels).forEach(d => {
                d3.select("div#line-button2")
                    .append("button")
                    .attr("class", lineButtonClasses[d])
                    .text(lineButtonLabels[d])
                    .on("click", function () {
                        yAxisToggle = Number(d);
                        updateLineGraph(xAxisToggle, yAxisToggle);
                        d3.selectAll("div#line-button2 button")
                            .classed("active", false);

                        d3.select(this).classed("active", true);
                    })
            });
            d3.select("#line-button2 button").classed("active", true);
        }
        requestData();


    </script>


    <script>
        // Flexible legend-drawing function - Jeff Rzeszotarski, 2022
        //   Released under MIT Free license
        function drawLegend(legendSelector, legendColorScale, formatValue) {
            d3.select(legendSelector).selectAll("*").remove(); //need this to prevent overlap

            // This code should adapt to a variety of different kinds of color scales

            // Shrink legend bar by 5 px inwards from sides of SVG
            const offsets = {
                width: 17,
                top: 2,
                bottom: 24
            };
            // Number of integer 'pixel steps' to draw when showing continuous scales
            const stepSize = 4;
            // Extend the minmax by 0% in either direction to expose more features by default
            const minMaxExtendPercent = 0;

            const legend = d3.select(legendSelector);
            const legendHeight = legend.attr("height");
            const legendBarWidth = legend.attr("width") - (offsets.width * 2);
            const legendMinMax = d3.extent(legendColorScale.domain());
            // recover the min and max values from most kinds of numeric scales
            const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
            const barHeight = legendHeight - offsets.top - offsets.bottom;

            // In this case the "data" are pixels, and we get numbers to use in colorScale
            // Use this to make axis labels
            let barScale = d3.scaleLinear().domain([legendMinMax[0] - minMaxExtension,
            legendMinMax[1] + minMaxExtension])
                .range([0, legendBarWidth]);

            //let barAxis = d3.axisBottom(barScale).tickFormat(formatValue);
            let barAxis = d3.axisBottom(barScale).tickFormat(formatValue);

            // Place for bar slices to live
            let bar = legend.append("g")
                .attr("class", "legend colorbar")
                .attr("transform", `translate(${offsets.width},${offsets.top})`)

            // ****** SWITCHES FOR DIFFERENT SCALE TYPES ******

            // Check if we're using a binning scale - if so, we make blocks of color
            if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
                // Get the thresholds
                let thresholds = [];
                if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
                else { thresholds = legendColorScale.quantiles() }

                const barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];

                // Use the quantile breakpoints plus the min and max of the scale as tick values
                barAxis.tickValues(barThresholds);

                // Draw rectangles between the threshold segments
                for (let i = 0; i < barThresholds.length - 1; i++) {
                    let dataStart = barThresholds[i];
                    let dataEnd = barThresholds[i + 1];
                    let pixelStart = barAxis.scale()(dataStart);
                    let pixelEnd = barAxis.scale()(dataEnd);

                    bar.append("rect")
                        .attr("x", pixelStart)
                        .attr("y", 0)
                        .attr("width", pixelEnd - pixelStart)
                        .attr("height", barHeight)
                        .style("fill", legendColorScale((dataStart + dataEnd) / 2.0));
                }
            }
            // Else if we have a continuous / roundable scale
            else if (legendColorScale.hasOwnProperty('rangeRound')) {
                for (let i = 0; i < legendBarWidth; i = i + stepSize) {

                    let center = i + (stepSize / 2);
                    let dataCenter = barAxis.scale().invert(center);

                    // below normal scale bounds
                    if (dataCenter < legendMinMax[0]) {
                        bar.append("rect")
                            .attr("x", i)
                            .attr("y", 0)
                            .attr("width", stepSize)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(legendMinMax[0]));
                    }
                    // within normal scale bounds
                    else if (dataCenter < legendMinMax[1]) {
                        bar.append("rect")
                            .attr("x", i)
                            .attr("y", 0)
                            .attr("width", stepSize)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(dataCenter));
                    }
                    // above normal scale bounds
                    else {
                        bar.append("rect")
                            .attr("x", i)
                            .attr("y", 0)
                            .attr("width", stepSize)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(legendMinMax[1]));
                    }
                }
            }
            // Otherwise we have a nominal scale
            else {
                let nomVals = legendColorScale.domain().sort();

                // Use a scaleBand to make blocks of color and simple labels
                let barScale = d3.scaleBand().domain(nomVals)
                    .range([0, legendBarWidth])
                    .padding(0.05);
                barAxis.scale(barScale);

                // Draw rectangles for each nominal entry
                nomVals.forEach(d => {
                    bar.append("rect")
                        .attr("x", barScale(d))
                        .attr("y", 0)
                        .attr("width", barScale.bandwidth())
                        .attr("height", barHeight)
                        .style("fill", legendColorScale(d));
                });
            }
            // DONE w/SWITCH

            // Finally, draw legend labels
            legend.append("g")
                .attr("class", "legend axis")
                .attr("transform", `translate(${offsets.width},${offsets.top + barHeight + 5})`)
                .call(barAxis);
        }
    </script>

</body>

</html>