<html>

<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
</head>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }


    body,
    html {
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
    }


    .container {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
    }


    .top-box {
        flex: 1;
        background-color: lightblue;
        display: flex;
        justify-content: center;
        align-items: center;


    }


    .bottom-container {
        display: flex;
        flex: 1;
    }


    .bottom-left,
    .bottom-right {
        flex: 1;
        display: flex;
        justify-content: center;
        /* align-items: center; */


        height: 100vh;
        align-items: flex-start;
    }


    .bottom-left {
        background-color: lightgreen;




    }


    .bottom-right {
        background-color: lightcoral;
    }


    .main-title {
        padding: 10px 20px;
        margin: 0 4px;
        border: none;
        border-radius: 4px;
        font-family: serif;
        position: absolute;
        top: 5%;
        left: 3%;
        font-size: 40px;
    }






    .county {
        fill: gray;
        stroke: none;
    }


    .state {
        stroke: black;
        stroke-width: 1px;
        fill: gray;
    }


    .outline {
        fill: none;
        stroke: black;
        stroke-width: 2px;
    }


    .statemap {
        fill: white;


        position: relative;
        /* display: flex; */
        gap: 8px;
        padding: 10px;
        border: none;
        border-radius: 4px;
        /* margin-top: 40px; */
        top: 99%;


    }


    .county-outline {
        fill: none;
        stroke: black;
        stroke-width: 1px
    }


    #button-bar button.health-spending {
        padding: 10px 20px;
        margin: 0 4px;
        border: none;
        border-radius: 4px;
        background-color: #11bc4a;
        cursor: pointer;
        font-family: serif;
        margin-bottom: 20%;
        /* transition-duration: 0.4s; */
        /* position: absolute; */
        /* top: 99%; */
        /* left: 99%; */
        display: block
    }


    #button-bar button.covid-deaths {
        padding: 10px 20px;
        margin: 0 4px;
        border: none;
        border-radius: 4px;
        background-color: #ba1a5a;
        cursor: pointer;
        font-family: serif;
        /* transition-duration: 0.4s; */
        /* position: absolute; */
        /* top: 99%; */
        /* left: 99%; */
        display: block
    }


    #button-bar button:hover {
        opacity: 0.9;
        color: rgb(162, 234, 236)
    }


    #button-bar-state {
        position: relative;
        display: flex;
        gap: 8px;
        padding: 10px;
        background-color: white;
        border: none;
        border-radius: 4px;
        margin-top: 20px;
        left: 50%;


    }

    .ustooltip {
        pointer-events: none;
    }
</style>


<body>
    <div class="container">


        <div class="top-box">
            <div class="main-title">Title</div>
            <div id="button-bar"></div>
            <!-- <div id="button-bar-state" style="display: none;"></div> -->
            <svg class="main-map" id="usmap" height="500" width="900" style="margin: auto 5px;
            float: left; "></svg>
            <div class="usmap-description">Box holder</div>
            <svg class="colorLegend" id="colorLegend" height="100" width="300"
                style="background: #fff; margin-top: 30%; margin-left: 1%;"></svg>




        </div>


        <div class="bottom-container">
            <div class="bottom-left">
                <div id="button-bar-state" style="display: none;"></div>
                <svg id="statemap" height="600" width="500"></svg>
            </div>
            <div class="bottom-right">
                <svg id="statemap" height="500" width="500" style="margin:20px"></svg>
                <svg id="colorLegend" height="80" width="600" style="background: #fff; margin-top:30px"></svg>
            </div>
        </div>


    </div>

    <script>
        // TO DO: 
        // flex boxes to organize for 3 separate graphs 
        // hover over each state (depending on toggle) to see name of state, value of data
        // make states disappear when you click on a different one
        // create toggle for individual state: county-level deaths & mask use 
        // create functionality to hover over individual county and see name of county & value of data
        // fix bar so the numbers dont all overlap 

        const buttonLabels = {
            0: "Health Spending \u{1F4B0}",
            1: "COVID-19 Deaths \u{2620} "
        }
        const buttonClasses = {
            0: "health-spending",
            1: "covid-deaths"
        }

        const stateButtonLabels = {
            0: "Mask Usage",
            1: "County-Level Deaths"
        };
        const stateButtonClasses = {
            0: "mask-usage",
            1: "county-deaths"
        };

        // VISUALIZATION 1 - map of US with health care spending for each state
        const svg1 = d3.select('svg#usmap');
        const width1 = svg1.attr('width');
        const height1 = svg1.attr('height');
        const margins1 = { top: 20, right: 20, bottom: 20, left: 20 };
        const mapWidth1 = width1 - margins1.left - margins1.right;
        const mapHeight1 = height1 - margins1.top - margins1.bottom;
        const usmap = svg1.append("g")
            .attr("transform", "translate(" + margins1.left + "," + margins1.top + ")");

        // VISUALIZATION 2 - covid cases by county
        const svg2 = d3.select('svg#statemap');
        const width2 = svg2.attr('width');
        const height2 = svg2.attr('height');
        const margins2 = { top: 20, right: 20, bottom: 20, left: 20 };
        const mapWidth2 = width2 - margins2.left - margins2.right;
        const mapHeight2 = height2 - margins2.top - margins2.bottom;
        const statemap = svg2.append("g")
            .attr("transform", "translate(" + margins2.left + "," + margins2.top + ")");

        const requestData = async function () {
            // import topoJSON for US map
            const us = await d3.json("us-counties.json");
            console.log(us);

            // VISUALIZATION 1
            // draw US map
            var states = topojson.feature(us, us.objects.states);
            var statesMesh = topojson.mesh(us, us.objects.states);
            var projection1 = d3.geoAlbersUsa().fitSize([mapWidth1, mapHeight1], states);
            var path1 = d3.geoPath().projection(projection1);

            // state paths
            let statePaths = usmap.selectAll("path.state").data(states.features)
                .join("path")
                .attr("class", "state")
                .attr("d", path1)
                .on('mouseover', mouseoverState)
                .on('mouseout', mouseoutState)
                .on('click', (event, d) => {
                    console.log(d);
                    updateStateMap(d);
                });

            const nyState = states.features.find(d => d.properties.name === "New York")
            if (nyState) {
                // Initialize with New York
                updateStateMap(nyState);
            }
            usmap.append("path").datum(statesMesh)
                .attr("class", "outline")
                .attr("d", path1);

            // import health spending data
            const healthSpendingData = await d3.csv("health_spending_data.csv");
            const hsc = 'Health Spending per Capita'
            healthSpendingData.forEach((d, i) => {
                d[hsc] = d[hsc].replace(/[$, ]/g, "").trim();
                d[hsc] = Number(d[hsc]);
            })
            console.log(healthSpendingData)

            // import COVID data
            const covidData = await d3.csv("us-counties-2020.csv", d3.autoType);

            // health data
            var healthSpendingDict = {};
            healthSpendingData.forEach(d => {
                const spending = parseFloat(d["Health Spending per Capita"]);
                healthSpendingDict[d.Location] = { total: spending };
            });

            // covid data
            var covidDeathsDict = {};
            covidData.forEach(d => {
                if (d.state in covidDeathsDict) {
                    covidDeathsDict[d.state] = { total: (covidDeathsDict[d.state].total + d.deaths) }
                } else {
                    covidDeathsDict[d.state] = { total: d.deaths }
                }
            });

            console.log(covidDeathsDict)

            const maskUsageData = await d3.csv("mask-use-by-county.csv");

            const maskUsageDict = {};

            maskUsageData.forEach(d => {
                maskUsageDict[d.COUNTYFP] = {
                    never: d.NEVER,
                    rarely: d.RARELY,
                    sometimes: d.SOMETIMES,
                    frequently: d.FREQUENTLY,
                    always: d.ALWAYS
                };
            });
            console.log("Mask Usage Dictionary:", maskUsageDict);


            const latestCovidData = covidData.filter(d => d.date === "2020-12-31");

            const fipsDeathsDict = {};
            latestCovidData.forEach(d => {
                const fips = d.fips;
                if (fips in fipsDeathsDict) {
                    fipsDeathsDict[fips] += d.deaths;
                } else {
                    fipsDeathsDict[fips] = d.deaths;
                }
            });

            var usData = [healthSpendingDict, covidDeathsDict];
            function updateUsScale(usToggle) {

                const formatValue = usToggle == 0
                    ? d3.format("$,.0f")  // Currency format for health spending
                    : d3.format(",d");    // Comma-separated integers for deaths


                let stateDict = usData[usToggle];
                console.log(stateDict);

                const colorScale = d3.scaleQuantile()
                    .domain(Object.values(stateDict).map(d => d.total))
                    .range(["#fff", "#d1e8ed", "#adc2da", "#8879b3", "#762b80"]);

                usmap.selectAll(".state")
                    .style("fill", d => {
                        const stateName = d.properties.name;
                        if (stateDict[stateName]) {
                            return colorScale(stateDict[stateName].total);
                        } else {
                            return "#ccc";
                        }
                    });
                drawLegend("#colorLegend", colorScale, formatValue)
            }


            // initialize us map
            let currentUsToggle = 1; // show covid death data initially
            updateUsScale(currentUsToggle);

            // buttons for map of US toggle
            const usKeys = Object.keys(usData);
            usKeys.forEach(d => {
                d3.select("div#button-bar")
                    .append("button")
                    .attr("class", buttonClasses[d])
                    .text(buttonLabels[d])
                    .on("click", function () {
                        currentUsToggle = Number(d);
                        updateUsScale(d);
                    })
            })

            // Mouseover tooltip stuff
            let ustooltipWidth = 110;
            let ustooltipHeight = 40;
            let usMouseoverMesh = usmap.append("path")
                .attr("class", "usmouseover outline")
                .style("stroke", "black")
                .style("stroke-width", 3)
                .attr("d", "");

            let ustooltip = usmap.append("g")
                .attr("class", "ustooltip")
                .attr("visibility", "hidden");

            ustooltip.append("rect")
                .attr("fill", "white")
                .attr("stroke", "black")
                .attr("stroke-width", 1)
                .attr("x", -ustooltipWidth / 2.0)
                .attr("y", 0)
                .attr("width", ustooltipWidth)
                .attr("height", ustooltipHeight)

            let stateLabel = ustooltip.append("text")
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "hanging")
                .attr("x", 0)
                .attr("y", 2);

            let usDataLabel = ustooltip.append("text")
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "hanging")
                .attr("x", 0)
                .attr("y", 22);

            // mouseoverState function to show name of state and amount of money on mouseover
            function mouseoverState(event, d) {
                ustooltip.style("visibility", "visible")


                let state = d3.select(this);
                state.style("stroke-width", "4px");


                // make label appear with name of state & value of data (can't figure out how to get data)
                let location = d3.pointer(event);
                let name = state.datum().properties.name;
                let stateDict = (currentUsToggle === 0) ? healthSpendingDict : covidDeathsDict;
                let value = stateDict[name].total;


                var dollarform = d3.format("$,.0f")
                stateLabel.text(name);
                usDataLabel.text((currentUsToggle === 0) ? dollarform(value) : d3.format(",d")(value));


                let bounds = path1.bounds(state.datum());
                let x = (bounds[0][0] + bounds[1][0]) / 2.0;
                let y = bounds[1][1] - 15;
                ustooltip.attr("transform", `translate(${x},${y})`);
                var mo = topojson.mesh(us, us.objects.states, function (a, b) { return a.id === name || b.id === name; });
                usMouseoverMesh.datum(mo).attr("d", path1)
            }


            // write mouseoutState function to get rid of label
            function mouseoutState() {
                ustooltip.style("visibility", "hidden");
                let state = d3.select(this);
                state.style("stroke-width", "1px");


                usMouseoverMesh.attr("d", "");
            }


            // make legend for the color scale 


            // VISUALIZATION 2



            // write updateState function to update map 2 with county-level COVID data for selected state
            function updateStateMap(selectedState) {
                // isolate counties for selected state

                //unclear previous state
                statemap.selectAll(".county").remove();
                statemap.selectAll(".county-outline").remove();
                statemap.selectAll(".outline").remove();
                d3.select("#button-bar-state").style("display", "none").selectAll("button").remove();



                //adding button to new state
                d3.select("#button-bar-state").style("display", "flex");


                Object.keys(stateButtonLabels).forEach(i => {
                    d3.select("#button-bar-state")
                        .append("button")
                        .attr("class", stateButtonClasses[i])
                        .text(stateButtonLabels[i])
                    //.on("click", function () {
                    //  updateCountyData(selectedState, i); 
                    //});
                });


                let selectedCounties = us.objects.counties.geometries.filter(function (d) { return selectedState.id == Math.floor(d.id / 1000) });
                var counties = topojson.feature(us, { type: "GeometryCollection", geometries: selectedCounties });
                var countiesMesh = topojson.mesh(us, { type: "GeometryCollection", geometries: selectedCounties });

                // create projection & path for selected state
                var stateProjection = d3.geoAlbersUsa().fitSize([mapWidth2, mapHeight2], selectedState);
                var statePath = d3.geoPath().projection(stateProjection);

                // Draw individual state outline
                statemap.append("path").datum(selectedState)
                    .attr("class", "outline")
                    .attr("d", statePath);

                // Draw counties within the selected state
                statemap.selectAll("path.county").data(counties.features)
                    .join("path")
                    .attr("class", "county")
                    .attr("d", statePath);

                statemap.append("path").datum(countiesMesh)
                    .attr("class", "county-outline")
                    .attr("d", statePath);

            }




        }
        requestData();
    </script>

    <script>
        // Flexible legend-drawing function - Jeff Rzeszotarski, 2022
        //   Released under MIT Free license
        //  Takes in an SVG element selector <legendSelector> and a d3 color scale <legendColorScale>
        //
        // Usage example: drawLegend("#legendID", grossIncomeColorScale)
        function drawLegend(legendSelector, legendColorScale, formatValue) {
            d3.select(legendSelector).selectAll("*").remove(); //need this to prevent overlap


            // This code should adapt to a variety of different kinds of color scales
            //  Credit Prof. Rz if you are basing a legend on this structure, and note PERFORMANCE CONSIDERATIONS

            // Shrink legend bar by 5 px inwards from sides of SVG
            const offsets = {
                width: 10,
                top: 2,
                bottom: 24
            };
            // Number of integer 'pixel steps' to draw when showing continuous scales
            //    Warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance -- keep this large
            const stepSize = 4;
            // Extend the minmax by 0% in either direction to expose more features by default
            const minMaxExtendPercent = 0;


            const legend = d3.select(legendSelector);
            const legendHeight = legend.attr("height");
            const legendBarWidth = legend.attr("width") - (offsets.width * 2);
            const legendMinMax = d3.extent(legendColorScale.domain());
            // recover the min and max values from most kinds of numeric scales
            const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
            const barHeight = legendHeight - offsets.top - offsets.bottom;

            // In this case the "data" are pixels, and we get numbers to use in colorScale
            // Use this to make axis labels
            let barScale = d3.scaleLinear().domain([legendMinMax[0] - minMaxExtension,
            legendMinMax[1] + minMaxExtension])
                .range([0, legendBarWidth]);

            let barAxis = d3.axisBottom(barScale).tickFormat(formatValue);

            // Place for bar slices to live
            let bar = legend.append("g")
                .attr("class", "legend colorbar")
                .attr("transform", `translate(${offsets.width},${offsets.top})`)

            // ****** SWITCHES FOR DIFFERENT SCALE TYPES ******

            // Check if we're using a binning scale - if so, we make blocks of color
            if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
                // Get the thresholds
                let thresholds = [];
                if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
                else { thresholds = legendColorScale.quantiles() }

                const barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];

                // Use the quantile breakpoints plus the min and max of the scale as tick values
                barAxis.tickValues(barThresholds);

                // Draw rectangles between the threshold segments
                for (let i = 0; i < barThresholds.length - 1; i++) {
                    let dataStart = barThresholds[i];
                    let dataEnd = barThresholds[i + 1];
                    let pixelStart = barAxis.scale()(dataStart);
                    let pixelEnd = barAxis.scale()(dataEnd);

                    bar.append("rect")
                        .attr("x", pixelStart)
                        .attr("y", 0)
                        .attr("width", pixelEnd - pixelStart)
                        .attr("height", barHeight)
                        .style("fill", legendColorScale((dataStart + dataEnd) / 2.0));
                }
            }
            // Else if we have a continuous / roundable scale
            //  In an ideal world you might construct a custom gradient mapped to the scale
            //  For this one, we use a hack of making stepped rects
            else if (legendColorScale.hasOwnProperty('rangeRound')) {
                // NOTE: The barAxis may round min and max values to make them pretty
                // ** This also means there is a risk of the legend going beyond scale bounds
                // We need to use the barAxis min and max just to be sure the bar is complete
                //    Using barAxis.scale().invert() goes from *axis* pixels to data values easily
                // ** We also need to create patches for the scale if the labels exceed bounds
                //     (floating point comparisons risky for small data ranges,but not a big deal
                //      because patches will be indistinguishable from actual scale bottom)
                // It's likely that scale clamping will actually do this for us elegantly
                // ...but better to be safer and patch the regions anyways

                for (let i = 0; i < legendBarWidth; i = i + stepSize) {

                    let center = i + (stepSize / 2);
                    let dataCenter = barAxis.scale().invert(center);

                    // below normal scale bounds
                    if (dataCenter < legendMinMax[0]) {
                        bar.append("rect")
                            .attr("x", i)
                            .attr("y", 0)
                            .attr("width", stepSize)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(legendMinMax[0]));
                    }
                    // within normal scale bounds
                    else if (dataCenter < legendMinMax[1]) {
                        bar.append("rect")
                            .attr("x", i)
                            .attr("y", 0)
                            .attr("width", stepSize)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(dataCenter));
                    }
                    // above normal scale bounds
                    else {
                        bar.append("rect")
                            .attr("x", i)
                            .attr("y", 0)
                            .attr("width", stepSize)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(legendMinMax[1]));
                    }

                }
            }
            // Otherwise we have a nominal scale
            else {
                let nomVals = legendColorScale.domain().sort();

                // Use a scaleBand to make blocks of color and simple labels
                let barScale = d3.scaleBand().domain(nomVals)
                    .range([0, legendBarWidth])
                    .padding(0.05);
                barAxis.scale(barScale);

                // Draw rectangles for each nominal entry
                nomVals.forEach(d => {
                    bar.append("rect")
                        .attr("x", barScale(d))
                        .attr("y", 0)
                        .attr("width", barScale.bandwidth())
                        .attr("height", barHeight)
                        .style("fill", legendColorScale(d));
                });
            }
            // DONE w/SWITCH

            // Finally, draw legend labels
            legend.append("g")
                .attr("class", "legend axis")
                .attr("transform", `translate(${offsets.width},${offsets.top + barHeight + 5})`)
                .call(barAxis);

        }
    </script>


</body>

</html>